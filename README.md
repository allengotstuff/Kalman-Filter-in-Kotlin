# Kalman-Filter-in-Kotlin

A **Kalman Filter** implementation in **Kotlin**, designed with built-in support for **debugging, calibration, visualization**, and additional tools to enhance usability.

## ðŸš§ Under Active Development ðŸš§

This repository is actively under development, and its API, architecture, or functionality may change frequently. **Backward compatibility is not guaranteed**, and breaking changes may occur without prior notice.

If you're using this project, following closely with development updates. **Contributions and feedback are welcome!**

## ðŸ“Œ What is Kalman Filter?

A **Kalman Filter** is an algorithm that provides an **optimal estimate of multidimensional variables in dynamic system** by iteratively refining predictions based on noisy sensor data. It is widely used in **robotics, tracking systems, navigation, and signal processing** due to its efficiency in filtering and predicting system states.

Specific use case of smartphone, including:
* GPS Positioning & Navigation
Problem: GPS signals are often noisy due to atmospheric interference, signal reflection, or loss in urban environments.
* Motion Tracking & Inertial Navigation (IMU Sensors)
  Problem: Smartphone accelerometers, gyroscopes, and magnetometers provide raw, noisy sensor readings.
* Camera Image Stabilization (OIS & EIS)
  Problem: Shaky hands cause unstable video recording and blurry photos.
* Touchscreen Smoothing & Gesture Recognition
  Problem: Raw touchscreen input contains noise, leading to shaky strokes in handwriting apps or inconsistent gestures.
* AR & VR of sensor reading to predict state of system. 

Mobile Application:
Apps like Ski Tracks, Strava, and Runkeeper use Kalman filtering to smooth motion tracking and estimate accurate speed and position.

### Why This Repository?

1. **Streamlined Calibration** â€“ Tuning a Kalman Filter requires extensive trial and error. This repository aims to provide **interactive and extendable tools** for calibrating systems modeling.
2. **Native Kotlin Support** â€“ Unlike other implementations, this repository is built natively in **Kotlin**, offering seamless integration with the Kotlin ecosystem.
3. **Enhanced Modeling Flexibility** â€“ Traditional Kalman Filter implementations often assume fixed parameters per iteration. This implementation supports **dynamic covariance updates**, enabling more adaptable system modeling.


### In Project Example 

![2d linear model](/asset/2d_linear_calibration.png)

This graph was generated by [linear_2d_calibration.ipynb](/src/notebook/linear_2d_calibration.ipynb), demonstrate example of how to calibrate a 2D linear system using artificial calibration datasets and a Kalman Filter. Below is a breakdown of the key elements and their significance:


**Key Elements:**
* **Red Line (Calibration_Hidden_State)**:Represents the true hidden state of the system, which acts as the ideal baseline for calibration.

* **Gray Line (KF_Measurement)**: Shows the noisy measurements of the system's state, reflecting the raw data collected during calibration.

* **Purple Line (KF_Estimate)**: Displays the Kalman Filter's estimated state, which progressively converges toward the true hidden state (red line), reducing noise.

**What This Graph Demonstrates:**
1. Noise in Measurements: The gray line represents noisy inputs commonly encountered in real-world systems. These fluctuations highlight the challenge of working with raw data.

2. Kalman Filter's Role: The purple line demonstrates how the Kalman Filter smooths the noisy data, providing a more accurate estimate of the system's state.

3. Calibration Accuracy: The red line serves as a benchmark, showing how closely the Kalman Filter's estimate aligns with the true state over time.

**Takeaway:**
This graph highlights the effectiveness of the Kalman Filter in handling noisy data and improving system calibration, making it a valuable tool for applications requiring precise state estimation.



---
## ðŸ“– Development Guide

### This project is best developed using ![IntelliJ IDEA](https://img.shields.io/badge/IDE-IntelliJ%20IDEA-blue?style=flat&logo=intellij-idea)


### **Module Overview**
- **`:core`** â€“ The fundamental Kalman Filter implementation, designed with **detailed documentation** explaining its inner workings. This package offers **maximum flexibility** for system modeling and can be extended as needed. It will be packaged for distribution.
- **`:utility`** â€“ Provides utility functions for testing, debugging, and calibrating both **KalmanFilterCore** and its application use cases
- **`:src`** - Contains examples demonstrating the usage of the Kalman Filter.


### Matrices and Vectors

The foundation of the Kalman Filter relies on **matrix and vector operations** for **multidimensional system modeling**. This implementation leverages **third-party libraries** for efficient computation.

Since **Kotlin lacks built-in matrix and vector operations**, this project uses:  
[Apache Commons Math](https://github.com/apache/commons-math) â€“ A **stable** and well-supported mathematical library.


### Kotlin Notebook (`src/notebook/`)
This folder contains **calibrated examples of Kalman Filter for custom systems**. It serves as both:
- The **practical tutorial** to learn the Kalman Filter with visualization.
- The **debugging and interactive tool**, allowing developers to refine system parameters for different application use cases.

**Powered by Kotlin Notebook** â€“ [Learn More](https://www.jetbrains.com/help/idea/kotlin-notebook.html).  
This is one of the core features of the repository, providing **interactive debugging, visualization, and rapid iteration**.

#### Best Practices: 
* Each Notebook file should focus on a single, unique system to serve as a clear example for developers, making it easier to find the relevant use case.
* Notebook files should follow clean code practices and include clear documentation.
* Custom classes and components used in a Notebook should be unit tested, or have unit tests added in `src/test`.
* Notebook filenames should follow the convention: `{system_modeling}_calibration.ipynb` (e.g., `linear_2d_calibration.ipynb`).
---

## ðŸ“¢ Contributions & Feedback

This project is open to contributions! Whether you want to improve documentation, optimize performance, or expand features, feel free to open an issue or submit a pull request.

ðŸš€ Happy coding!
